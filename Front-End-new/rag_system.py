import os
import logging
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from datetime import datetime
import aiohttp
import json

# AI / LangChain
from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_community.vectorstores import SupabaseVectorStore
from langchain.schema import Document
from langchain.chains import ConversationalRetrievalChain
from langchain.memory import ConversationBufferMemory

# Supabase
from supabase import create_client, Client

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class RAGConfig:
    openai_api_key: str
    supabase_url: str
    supabase_key: str
    model_name: str = os.getenv("MODEL_NAME", "gpt-3.5-turbo")
    temperature: float = float(os.getenv("MODEL_TEMPERATURE", "0.7"))
    max_tokens: int = int(os.getenv("MODEL_MAX_TOKENS", "1000"))
    chunk_size: int = 1000
    chunk_overlap: int = 200
    table_name: str = os.getenv("VECTOR_TABLE", "documents")
    query_name: str = os.getenv("VECTOR_QUERY_FN", "match_documents")

class SupabaseRAG:
    def __init__(self, config: RAGConfig):
        self.config = config
        self.supabase: Optional[Client] = None
        self.llm = None
        self.embeddings = None
        self.vector_store = None
        self.chain = None
        self.memory = None
        self._initialize()

    def _initialize(self):
        try:
            # Supabase
            self.supabase = create_client(self.config.supabase_url, self.config.supabase_key)
            logger.info("Supabase client initialized")

            # OpenAI
            self.llm = ChatOpenAI(
                model=self.config.model_name,
                temperature=self.config.temperature,
                max_tokens=self.config.max_tokens,
                openai_api_key=self.config.openai_api_key,
            )
            logger.info("OpenAI LLM initialized")

            # Embeddings
            self.embeddings = OpenAIEmbeddings(
                openai_api_key=self.config.openai_api_key
            )
            logger.info("OpenAI Embeddings initialized")

            # Vector store
            self.vector_store = SupabaseVectorStore(
                client=self.supabase,
                embedding=self.embeddings,
                table_name=self.config.table_name,
                query_name=self.config.query_name
            )
            logger.info("Vector store initialized")

            # Conversational RAG chain
            self.memory = ConversationBufferMemory(
                memory_key="chat_history",
                return_messages=True,
                input_key="question",
                output_key="answer"
            )
            
            self.chain = ConversationalRetrievalChain.from_llm(
                llm=self.llm,
                retriever=self.vector_store.as_retriever(search_kwargs={"k": 5}),
                memory=self.memory,
                return_source_documents=True,
                verbose=True,
                output_key="answer"
            )
            logger.info("Conversational chain initialized")

        except Exception as e:
            logger.error(f"Error initializing RAG system: {e}")
            raise

    def get_smart_response(self, question: str, user_name: Optional[str] = None) -> Optional[str]:
        """Get smart responses for general and site-related questions"""
        if not question:
            return None
            
        q = question.lower().strip()
        hello = f"ุฃููุงู {user_name}!" if user_name else "ุฃููุงู ูุณููุงู!"
        
        logger.info(f"Checking smart response for: '{q}'")
        
        # Check if any keyword matches
        keywords = ["ุงููุง", "ุฃููุง", "ูุฑุญุจุง", "ุงูุณูุงู ุนูููู", "hello", "hi", "ูุฑุญุจุชูู", "ููุง", "ุฃูููู"]
        for keyword in keywords:
            if keyword in q:
                logger.info(f"Found keyword: '{keyword}' in '{q}'")
                response = f"{hello} ููู ุญุงููุ ุฃูุง ุตุฏููุ ูุณุงุนุฏู ุงูุฐูู ูู ุฏูุงู ูุฌูุ ุณุนูุฏ ุจููุงุฆู."
                logger.info(f"Returning smart response: {response}")
                return response

        # ๐น ุงูุชุญูุงุช ูุงููุฏุงุน
        if any(w in q for w in ["ุงููุง", "ุฃููุง", "ูุฑุญุจุง", "ุงูุณูุงู ุนูููู", "hello", "hi", "ูุฑุญุจุชูู", "ููุง", "ุฃูููู"]):
            return f"{hello} ููู ุญุงููุ ุฃูุง ุตุฏููุ ูุณุงุนุฏู ุงูุฐูู ูู ุฏูุงู ูุฌูุ ุณุนูุฏ ุจููุงุฆู."
        if any(w in q for w in ["ูุน ุงูุณูุงูุฉ", "ุฅูู ุงูููุงุก", "goodbye", "bye", "ุณูุงู", "ุจุงู"]):
            return "ูุฏุงุนุงู! ูุชููู ูู ูููุงู ุณุนูุฏุงู."
        if any(w in q for w in ["ููู ุงูุญุงู", "ููู ุญุงูู", "how are you", "ุดุฎุจุงุฑู", "ุดูููู", "ูููู"]):
            return f"ุงูุญูุฏ ููู ุจุฎูุฑ {user_name or ''}. ููู ุฃูุฏุฑ ุฃุณุงุนุฏู ุงููููุ"
        if any(w in q for w in ["ุดูุฑุง", "ุดูุฑุงู", "thank you", "thanks", "ูุดููุฑ", "ุชุณูู"]):
            return f"ุงูุนูู {user_name or ''}! ุณุนูุฏ ุจูุณุงุนุฏุชู."
        
        # ๐น ุนู ุงููุณุงุนุฏ ููุณู
        if any(w in q for w in ["ุงุณูู", "your name", "ูู ุงูุช", "ูู ุฃูุช", "ูุด ุงุณูู", "ูุง ุงุณูู"]):
            return "ุฃูุง ุตุฏููุ ูุณุงุนุฏู ุงูุฐูู ูู ุฏูุงู ูุฌู. ุฃุณุงุนุฏู ูู ุงูุชุณูู ูุงูุฅุฌุงุจุฉ ุนูู ุฃุณุฆูุชู."
        
        # ๐น ุนู ุงููุณุชุฎุฏู
        if any(w in q for w in ["ูุด ุงุณูู", "ูุง ุงุณูู", "ุงุณูู", "my name", "who am i", "ูู ุฃูุง"]):
            if user_name and user_name != "ูุณุชุฎุฏู":
                return f"ุงุณูู {user_name} ๐"
            else:
                return "ุนุฐุฑุงูุ ูุง ุฃุนุฑู ุงุณูู. ูู ููููู ุฅุฎุจุงุฑู ุจุงุณููุ"
        if any(w in q for w in ["ูุด ุชูุฏุฑ ุชุณูู", "what can you do", "ูุฏุฑุงุชู", "ูุด ุชุณูู", "ุฅูุด ุชูุฏุฑ"]):
            return "ุฃุณุงุนุฏู ูู: ุงูุจุญุซ ุนู ุงูููุชุฌุงุชุ ูุนุฑูุฉ ุงููุฑูุนุ ุทุฑู ุงูุฏูุนุ ุงูููุงุชูุฑุ ุฅูุฎ."
        
        # ๐น ุนู ุฏูุงู ูุฌู
        if any(w in q for w in ["ุฏูุงู ูุฌู", "ุงูุดุฑูุฉ", "company", "ุงููุชุฌุฑ", "ุงูููุตุฉ"]):
            return f"ุฏูุงู ูุฌู {hello} ููุตุฉ ุณุนูุฏูุฉ ูุจุชูุฑุฉ ุชูุฏู ุชุฌุฑุจุฉ ุชุณูู ุฐููุฉุ ุชุฏุฎูุ ุชุฎุชุงุฑ ููุชุฌุงุชูุ ูุชุฎุฑุฌ ุจุฏูู ุงูุญุงุฌุฉ ูููููู ุนูุฏ ุงููุงุดูุฑ."
        if any(w in q for w in ["qr", "ููู ุขุฑ", "ุจุงุฑููุฏ", "ููุฏ"]):
            return "ูู ุฏูุงู ูุฌู ุชุจุฏุฃ ุฑุญูุชู ุจูุณุญ ููุฏ QRุ ููู ุซู ููููู ุงูุชุณูู ุจุญุฑูุฉ ูุงูุฏูุน ูุชู ุจุดูู ุชููุงุฆู ูุณูุณ ุนูุฏ ุงููุบุงุฏุฑุฉ."

        elif any(w in q for w in ["ุฐูุงุก ุงุตุทูุงุนู", "ai", "artificial intelligence", "ุงูุฐูุงุก"]):
            return "ูุณุชุฎุฏู ุชูููุงุช ุงูุฐูุงุก ุงูุงุตุทูุงุนู ูุชุชุจุน ุงููุดุชุฑูุงุชุ ุชุฎุตูุต ุงูุนุฑูุถุ ูุถูุงู ุชุฌุฑุจุฉ ุณูุณุฉ ุจุฏูู ุชุฏุฎู ูุฏูู."

        elif any(w in q for w in ["ุขูุฉ ุจูุน", "ูุงูููุฉ", "vending machine", "ูุงูููุงุช"]):
            return "ุขูุงุชูุง ููุณุช ูุฌุฑุฏ ูุงูููุงุช ุจูุน ุชูููุฏูุฉุ ุจู ูู ููุตุงุช ุฐููุฉ ุชุชูุญ ูู ุงูุฏุฎููุ ุงุฎุชูุงุฑ ุงูููุชุฌุงุชุ ูุงูุฎุฑูุฌ ูุงูุฏูุน ูุจุงุดุฑุฉ ุจุฏูู ุงูุชุธุงุฑ."

        # ๐น ุทุฑู ุงูุดุฑุงุก ูุงูุฏูุน
        if any(w in q for w in ["ููู ุฃุดุชุฑู", "ุทุฑููุฉ ุงูุฏูุน", "ููู ุฃุณุชุฎุฏู", "ุทุฑููุฉ ุงูุดุฑุงุก", "ูุด ุชูุฏู ุงูููุตุฉ", "ุงูุฎุฏูุงุช"]):
            return f"ุฏูุงู ูุฌู {hello} ููุฏู: 1) ุชุณูู ุณุฑูุน ุนุจุฑ QRุ 2) ููุชุฌุงุช ูุชููุนุฉ (ูุดุฑูุจุงุชุ ูุฌุจุงุช ุฎูููุฉ)ุ 3) ุฏูุน ุฅููุชุฑููู ุขููุ 4) ูุฑูุน 24/7ุ 5) ุชุฌุฑุจุฉ ุฐููุฉ ูุฎุตุตุฉ."
        if any(w in q for w in ["ููู ุงุฏูุน", "ุทุฑู ุงูุฏูุน", "payment", "ุฏูุน"]):
            return "ูุฏุนู ูู ุฏูุงู ูุฌู: ูุฏู/ุจุทุงูุงุชุ Apple Pay/Google Payุ ููุฏุงูุ ูSTC Pay."
        
        # ๐น ุงููุฑูุน ูุงูููุงูุน
        if any(w in q for w in ["ุฃูู ุงููุฑูุน", "ููู ูููุนูู", "ูุฑูุน", "branches", "locations"]):
            return f"ูุฏููุง ูุฑูุน ุฏูุงู ูุฌู ูู ุงูุฑูุงุถ ูุฌุฏุฉ ูุงูุฏูุงู ูุงูุฎุจุฑ ูุงููุฏููุฉ {hello}."
        if any(w in q for w in ["ูุชู ุชูุชุญูู", "ุณุงุนุงุช ุงูุนูู", "open"]):
            return "ูุฑูุน ุฏูุงู ูุฌู ุชุนูู 24/7 ูุชูููุฑ ุงูุฎุฏูุฉ ุนูู ูุฏุงุฑ ุงูุณุงุนุฉ."
        if any(w in q for w in ["ูู ุงูุฃุณุนุงุฑ", "price", "ุงูุณุนุฑ", "ุงูุชูููุฉ"]):
            return f"ุฃุณุนุงุฑ ุฏูุงู ูุฌู {hello} ุชุชุฑุงูุญ ูู 2.50 ุฑ.ุณ ุฅูู 8.00 ุฑ.ุณ ุญุณุจ ุงูููุชุฌ."
        
        # ๐น ูุนูููุงุช ุนุงูุฉ
        if any(w in q for w in ["ุงูุทูุณ", "weather"]):
            return "ูุง ุฃูุฏุฑ ุฃุฌูุจ ุงูุทูุณ ุงูุขูุ ููู ุฃูุฏุฑ ุฃุณุงุนุฏู ูู ุงูุชุณูู ูู ุฏูุงู ูุฌู."
        if any(w in q for w in ["ุงูุชุงุฑูุฎ", "date", "ุงูููู"]):
            return f"ุงูุชุงุฑูุฎ: {datetime.now().strftime('%Y/%m/%d')}"
        
        # ๐น ุฃุณุฆูุฉ ุงูููุชุฌุงุช ุงูุฐููุฉ
        if any(w in q for w in ["ุงุนูู ุณุนุฑ", "ุฃุนูู ุณุนุฑ", "ุงุบูู", "ุฃุบูู", "ุฃุนูู ุชูููุฉ", "ุงุนูู ุชูููุฉ", "highest price", "most expensive"]):
            return "smart_product_query: highest_price"
        if any(w in q for w in ["ุงูู ุณุนุฑ", "ุฃูู ุณุนุฑ", "ุงุฑุฎุต", "ุฃุฑุฎุต", "ุฃูู ุชูููุฉ", "ุงูู ุชูููุฉ", "lowest price", "cheapest"]):
            return "smart_product_query: lowest_price"
        if any(w in q for w in ["ุงุนูู ูุงููุฑู", "ุฃุนูู ูุงููุฑู", "ุฃุนูู ุณุนุฑุงุช", "ุงุนูู ุณุนุฑุงุช", "highest calories", "most calories"]):
            return "smart_product_query: highest_calories"
        
        # ๐น ุฃุณุฆูุฉ ุงูุณุนุฑุงุช ุงูุญุฑุงุฑูุฉ
        if any(w in q for w in ["ูู ููู ุณุนุฑุฉ", "ูู ุณุนุฑุฉ", "ูู ุณุนุฑุงุช", "ูู ุณุนุฑุงุช ุญุฑุงุฑูุฉ", "calories", "ุณุนุฑุงุช ุญุฑุงุฑูุฉ", "ุณุนุฑุฉ ุญุฑุงุฑูุฉ"]):
            return "smart_product_query: all_calories"
        
        # ๐น ุฃุณุฆูุฉ ูุญุฏุฏุฉ ููููุชุฌุงุช
        if any(w in q for w in ["ูู ุณุนุฑ ุงูุนุตูุฑ", "ุณุนุฑ ุงูุนุตูุฑ", "ุชูููุฉ ุงูุนุตูุฑ", "price of juice"]):
            return "smart_product_query: juice_prices"
        if any(w in q for w in ["ูู ุณุนุฑ ุงูุญููุจ", "ุณุนุฑ ุงูุญููุจ", "ุชูููุฉ ุงูุญููุจ", "price of milk"]):
            return "smart_product_query: milk_prices"
        if any(w in q for w in ["ูู ุณุนุฑ ุงูุดููููุงุชุฉ", "ุณุนุฑ ุงูุดููููุงุชุฉ", "ุชูููุฉ ุงูุดููููุงุชุฉ", "price of chocolate"]):
            return "smart_product_query: chocolate_prices"
        
        # ๐น ูุทุงู ุงููุนุฑูุฉ
        if any(w in q for w in ["ูุทุงู ูุนุฑูุชู", "ูุทุงู ุงููุนุฑูุฉ", "ูุฏุฑุงุชู", "ูุด ุชูุฏุฑ", "ุฅูุด ุชูุฏุฑ"]):
            return f"ูุทุงู ูุนุฑูุชู {hello} ูุชุฑูุฒ ุนูู ุฏูุงู ูุฌู: ุงูููุชุฌุงุชุ ุงููุฑูุนุ ุงูููุงุชูุฑุ ุทุฑู ุงูุฏูุนุ ุงูุฎุฏูุงุชุ ูุงูุชุณูู ุงูุฐูู. ูููููู ูุณุงุนุฏุชู ูู ุฃู ุงุณุชูุณุงุฑ ุญูู ุฎุฏูุงุชูุง."
        
        # ๐น ุงูุณูุงู ูุงูููุตุฉ
        if any(w in q for w in ["ุงูููุตุฉ", "platform", "ุงูุณูุงู", "context"]):
            return f"ุงูููุตุฉ ุงูุชู ุฃุชุญุฏุซ ุนููุง ูู ุฏูุงู ูุฌู {hello} - ููุตุฉ ุงูุชุณูู ุงูุฐูู ุงูุณุนูุฏูุฉ. ูุญู ููุฏู ุฎุฏูุงุช ุงูุจูุน ุงูุขูู ุงูุฐูู ูุน ุชุฌุฑุจุฉ ุฏูุน ุณุฑูุนุฉ ูุขููุฉ."
        
        # ๐น ููุงุฑูุฉ ุงูุฃุณุนุงุฑ
        if any(w in q for w in ["ูุงุฑู", "ููุงุฑูุฉ", "ููุงุฑูู", "compare", "competition", "ููุงูุณุฉ", "ููุงูุณูู", "ุงูุงุณูุงู", "ูุชุฌุฑ ุงุฎุฑ", "ูุชุฌุฑ ุขุฎุฑ"]):
            return "smart_product_query: price_comparison"
        
        # ๐น ุฃุณุฆูุฉ ูุนูููุงุช ุงูููุชุฌุงุช
        product_keywords = ["ุนุตูุฑ ุงููุฑุงุนู", "ุนุตูุฑ ุงูุฑุจูุน", "ุจุงุฑูู", "ุจุณูุฑูู", "ุฌุงููุณู", "ุณููุชูุฒ", "ููุช ูุงุช", "ููููุฑ", "ุญููุจ ูุงุฏู", "ุฃูุฑูู", "ุจุฑูุชูู ุจุงุฑ", "ุตู ุชูุจ"]
        for product in product_keywords:
            if product.lower() in q:
                return f"smart_product_query: product_info:{product}"
        
        return None

    def translate_product_name(self, name: str) -> str:
        """Translate product name from English to Arabic"""
        translations = {
            'Almarai_juice': 'ุนุตูุฑ ุงููุฑุงุนู',
            'alrabie_juice': 'ุนุตูุฑ ุงูุฑุจูุน',
            'Nadec_Mlik': 'ุญููุจ ูุงุฏู',
            'Sun_top': 'ุตู ุชูุจ',
            'barni': 'ุจุงุฑูู',
            'biskrem': 'ุจุณูุฑูู',
            'loacker': 'ููููุฑ',
            'oreos': 'ุฃูุฑูู',
            'galaxy': 'ุฌุงููุณู',
            'green_skittles': 'ุณููุชูุฒ ุฃุฎุถุฑ',
            'kit_kat': 'ููุช ูุงุช',
            'pink_skittles': 'ุณููุชูุฒ ูุฑุฏู',
            'protein_bar': 'ุจุฑูุชูู ุจุงุฑ'
        }
        return translations.get(name, name)

    def format_products(self, products: List[Dict], show_prices: bool = True) -> str:
        """Format products for display"""
        if not products:
            return "ูุง ุชูุฌุฏ ููุชุฌุงุช ูุชููุฑุฉ."
        out = []
        for i, p in enumerate(products, 1):
            name = self.translate_product_name(p.get('name', ''))
            if show_prices:
                price = p.get('price', 0)
                out.append(f"{i}. {name} - {price} ุฑ.ุณ")
            else:
                out.append(f"{i}. {name}")
        return "\n".join(out)
    
    def get_highest_price_product(self, products: List[Dict]) -> Dict:
        """Get product with highest price"""
        if not products:
            return {}
        return max(products, key=lambda x: x.get('price', 0))
    
    def get_lowest_price_product(self, products: List[Dict]) -> Dict:
        """Get product with lowest price"""
        if not products:
            return {}
        return min(products, key=lambda x: x.get('price', 0))
    
    def get_highest_calorie_product(self, products: List[Dict]) -> Dict:
        """Get product with highest calories"""
        if not products:
            return {}
        return max(products, key=lambda x: x.get('calories', 0))

    async def get_product_info_from_web(self, product_name: str) -> str:
        """Get additional product information from web search"""
        try:
            # Use OpenAI to get product information
            prompt = f"""
            ุฃุนุทูู ูุนูููุงุช ูููุฏุฉ ููุฎุชุตุฑุฉ ุนู ุงูููุชุฌ ุงูุชุงูู: {product_name}
            
            ุฃุฑูุฏ ูุนูููุงุช ุนู:
            - ุงูููููุงุช ุงูุฑุฆูุณูุฉ
            - ุงูููุงุฆุฏ ุงูุตุญูุฉ
            - ุงููููุฉ ุงูุบุฐุงุฆูุฉ
            - ูุตุงุฆุญ ููุงุณุชููุงู
            - ูุนูููุงุช ุนุงูุฉ ูุซูุฑุฉ ููุงูุชูุงู
            
            ุงูุชุจ ุงูุฅุฌุงุจุฉ ุจุงููุบุฉ ุงูุนุฑุจูุฉ ูุจุดูู ูุฎุชุตุฑ ููููุฏ.
            """
            
            response = await asyncio.to_thread(
                openai.ChatCompletion.create,
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "ุฃูุช ูุณุงุนุฏ ูุชุฎุตุต ูู ูุนูููุงุช ุงูููุชุฌุงุช ุงูุบุฐุงุฆูุฉ. ุฃุนุท ูุนูููุงุช ุฏูููุฉ ููููุฏุฉ."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=300,
                temperature=0.7
            )
            
            return response.choices[0].message.content.strip()
            
        except Exception as e:
            logger.error(f"Error getting product info from web: {e}")
            return "ุนุฐุฑุงูุ ูุง ูููููู ุฌูุจ ูุนูููุงุช ุฅุถุงููุฉ ุนู ูุฐุง ุงูููุชุฌ ุญุงููุงู."

    def format_branches(self, branches: List[Dict]) -> str:
        """Format branches for display"""
        if not branches:
            return "ูุง ุชูุฌุฏ ูุฑูุน ูุชููุฑุฉ."
        out = []
        for i, b in enumerate(branches, 1):
            out.append(f"{i}. {b.get('name','')} - {b.get('address','')}")
        return "\n".join(out)

    def format_invoices(self, invoices: List[Dict]) -> str:
        """Format invoices for display"""
        if not invoices:
            return "ูุง ุชูุฌุฏ ููุงุชูุฑ ููุฐุง ุงููุณุชุฎุฏู."
        out = []
        for i, inv in enumerate(invoices, 1):
            out.append(f"{i}. ID: {inv.get('id','')}, ุงููุฌููุน: {inv.get('total_amount',0)} ุฑ.ุณ, ุงูุญุงูุฉ: {inv.get('status','')}")
        return "\n".join(out)

    async def ask_question(self, question: str, user_id: Optional[str] = None, user_name: Optional[str] = None):
        try:
            if not question or not question.strip():
                return {
                    "answer": "ูุฑุฌู ุฅุฏุฎุงู ุณุคุงู ุตุญูุญ.",
                    "source": "validation_error",
                    "confidence": 0.0
                }
            
            question = question.strip()
            logger.info(f"Question: '{question}'")
            logger.info(f"User ID: {user_id}")
            logger.info(f"User name: {user_name}")
            
            # First check for smart responses
            smart_response = self.get_smart_response(question, user_name)
            logger.info(f"Smart response: {smart_response}")
            
            if smart_response:
                logger.info(f"Smart response: {smart_response}")
                
                # Handle smart product queries
                if smart_response.startswith("smart_product_query:"):
                    query_type = smart_response.split(":")[1].strip()
                    data = await self.load_database_data(user_id)
                    products = data['products']
                    
                    if query_type == "highest_price":
                        product = self.get_highest_price_product(products)
                        if product:
                            name = self.translate_product_name(product.get('name', ''))
                            price = product.get('price', 0)
                            return {
                                "answer": f"ุฃุนูู ุณุนุฑ ูู ุฏูุงู ูุฌู ูู {name} ุจุณุนุฑ {price} ุฑ.ุณ",
                                "source": "database",
                                "confidence": 1.0
                            }
                    
                    elif query_type == "lowest_price":
                        product = self.get_lowest_price_product(products)
                        if product:
                            name = self.translate_product_name(product.get('name', ''))
                            price = product.get('price', 0)
                            return {
                                "answer": f"ุฃูู ุณุนุฑ ูู ุฏูุงู ูุฌู ูู {name} ุจุณุนุฑ {price} ุฑ.ุณ",
                                "source": "database",
                                "confidence": 1.0
                            }
                    
                    elif query_type == "highest_calories":
                        product = self.get_highest_calorie_product(products)
                        if product:
                            name = self.translate_product_name(product.get('name', ''))
                            calories = product.get('calories', 0)
                            return {
                                "answer": f"ุฃุนูู ุณุนุฑุงุช ุญุฑุงุฑูุฉ ูู ุฏูุงู ูุฌู ูู {name} ุจู {calories} ุณุนุฑุฉ ุญุฑุงุฑูุฉ",
                                "source": "database",
                                "confidence": 1.0
                            }
                    
                    elif query_type == "juice_prices":
                        juice_products = [p for p in products if "ุนุตูุฑ" in self.translate_product_name(p.get('name', '')).lower()]
                        if juice_products:
                            result = "ุฃุณุนุงุฑ ุงูุนุตุงุฆุฑ ูู ุฏูุงู ูุฌู:\n"
                            for product in juice_products:
                                name = self.translate_product_name(product.get('name', ''))
                                price = product.get('price', 0)
                                result += f"โข {name}: {price} ุฑ.ุณ\n"
                            return {
                                "answer": result,
                                "source": "database",
                                "confidence": 1.0
                            }
                    
                    elif query_type == "milk_prices":
                        milk_products = [p for p in products if "ุญููุจ" in self.translate_product_name(p.get('name', '')).lower()]
                        if milk_products:
                            result = "ุฃุณุนุงุฑ ุงูุญููุจ ูู ุฏูุงู ูุฌู:\n"
                            for product in milk_products:
                                name = self.translate_product_name(product.get('name', ''))
                                price = product.get('price', 0)
                                result += f"โข {name}: {price} ุฑ.ุณ\n"
                            return {
                                "answer": result,
                                "source": "database",
                                "confidence": 1.0
                            }
                    
                    elif query_type == "chocolate_prices":
                        chocolate_products = [p for p in products if any(w in self.translate_product_name(p.get('name', '')).lower() for w in ["ุจุงุฑูู", "ุฌุงููุณู", "ููุช ูุงุช", "ุฃูุฑูู"])]
                        if chocolate_products:
                            result = "ุฃุณุนุงุฑ ุงูุดููููุงุชุฉ ูู ุฏูุงู ูุฌู:\n"
                            for product in chocolate_products:
                                name = self.translate_product_name(product.get('name', ''))
                                price = product.get('price', 0)
                                result += f"โข {name}: {price} ุฑ.ุณ\n"
                            return {
                                "answer": result,
                                "source": "database",
                                "confidence": 1.0
                            }
                    
                    elif query_type == "all_calories":
                        # Filter products that have calories data
                        products_with_calories = [p for p in products if p.get('calories', 0) > 0]
                        if products_with_calories:
                            result = "ุงูุณุนุฑุงุช ุงูุญุฑุงุฑูุฉ ููููุชุฌุงุช ูู ุฏูุงู ูุฌู:\n"
                            for product in products_with_calories:
                                name = self.translate_product_name(product.get('name', ''))
                                calories = product.get('calories', 0)
                                result += f"โข {name}: {calories} ุณุนุฑุฉ ุญุฑุงุฑูุฉ\n"
                            return {
                                "answer": result,
                                "source": "database",
                                "confidence": 1.0
                            }
                        else:
                            return {
                                "answer": "ุนุฐุฑุงูุ ูุง ุชุชููุฑ ูุนูููุงุช ุงูุณุนุฑุงุช ุงูุญุฑุงุฑูุฉ ููููุชุฌุงุช ุญุงููุงู.",
                                "source": "database",
                                "confidence": 1.0
                            }
                    
                    elif query_type == "price_comparison":
                        # Create a price comparison response
                        result = "ููุงุฑูุฉ ุฃุณุนุงุฑ ุฏูุงู ูุฌู ูุน ุงููุชุงุฌุฑ ุงูุฃุฎุฑู:\n\n"
                        result += "๐ช **ุฏูุงู ูุฌู:**\n"
                        result += "โข ุฃุณุนุงุฑ ุชูุงูุณูุฉ ุชุชุฑุงูุญ ูู 2.50 ุฑ.ุณ ุฅูู 8.00 ุฑ.ุณ\n"
                        result += "โข ูุง ุชูุฌุฏ ุฑุณูู ุฅุถุงููุฉ ุฃู ุนูููุงุช\n"
                        result += "โข ุฏูุน ุฅููุชุฑููู ุขูู ูุณุฑูุน\n"
                        result += "โข ุฎุฏูุฉ 24/7 ุจุฏูู ุงูุชุธุงุฑ\n\n"
                        
                        result += "๐ **ุงููุชุงุฌุฑ ุงูุชูููุฏูุฉ:**\n"
                        result += "โข ุฃุณุนุงุฑ ููุงุซูุฉ ุฃู ุฃุนูู ููููุงู\n"
                        result += "โข ูุฏ ุชูุฌุฏ ุฑุณูู ุชูุตูู ุฅุถุงููุฉ\n"
                        result += "โข ููุช ุงูุชุธุงุฑ ูู ุงูุทูุงุจูุฑ\n"
                        result += "โข ุณุงุนุงุช ุนูู ูุญุฏูุฏุฉ\n\n"
                        
                        result += "๐ก **ูุฒุงูุง ุฏูุงู ูุฌู:**\n"
                        result += "โข ุชุฌุฑุจุฉ ุชุณูู ุณุฑูุนุฉ ููุฑูุญุฉ\n"
                        result += "โข ุชูููุฑ ุงูููุช ูุงูุฌูุฏ\n"
                        result += "โข ุชูููุงุช ุฐููุฉ ูุชุทูุฑุฉ\n"
                        result += "โข ุฃุณุนุงุฑ ุดูุงูุฉ ุจุฏูู ููุงุฌุขุช"
                        
                        return {
                            "answer": result,
                            "source": "smart_response",
                            "confidence": 1.0
                        }
                    
                    elif query_type.startswith("product_info:"):
                        product_name = query_type.split(":", 1)[1]
                        # Get basic product info from database
                        data = await self.load_database_data(user_id)
                        products = data['products']
                        
                        # Find the product in database
                        product_info = None
                        for product in products:
                            if product_name.lower() in self.translate_product_name(product.get('name', '')).lower():
                                product_info = product
                                break
                        
                        if product_info:
                            # Get additional info from web
                            web_info = await self.get_product_info_from_web(product_name)
                            
                            result = f"๐ฆ **ูุนูููุงุช {product_name}:**\n\n"
                            result += f"๐ฐ **ุงูุณุนุฑ:** {product_info.get('price', 0)} ุฑ.ุณ\n"
                            if product_info.get('calories', 0) > 0:
                                result += f"๐ฅ **ุงูุณุนุฑุงุช ุงูุญุฑุงุฑูุฉ:** {product_info.get('calories', 0)} ุณุนุฑุฉ ุญุฑุงุฑูุฉ\n"
                            result += f"\n๐ **ูุนูููุงุช ุฅุถุงููุฉ:**\n{web_info}"
                            
                            return {
                                "answer": result,
                                "source": "database_and_web",
                                "confidence": 1.0
                            }
                        else:
                            # Product not found in database, but get web info anyway
                            web_info = await self.get_product_info_from_web(product_name)
                            result = f"๐ฆ **ูุนูููุงุช {product_name}:**\n\n"
                            result += f"๐ **ูุนูููุงุช ูู ุงูุฅูุชุฑูุช:**\n{web_info}"
                            
                            return {
                                "answer": result,
                                "source": "web_only",
                                "confidence": 0.8
                            }
                
                return {
                    "answer": smart_response,
                    "source": "smart_response",
                    "confidence": 1.0
                }
            
            logger.info("No smart response found, checking database queries...")
            
            # Check for specific data queries with better context understanding
            q_lower = question.lower()
            
            # Products queries - Smart handling
            if any(k in q_lower for k in ["ุงูููุชุฌุงุช", "products", "product", "ูุด ุงูููุชุฌุงุช", "ูุง ูู ุงูููุชุฌุงุช", "ุนุฑุถ ุงูููุชุฌุงุช"]):
                data = await self.load_database_data(user_id)
                # Show only names if asking about products generally
                if any(w in q_lower for w in ["ุงูููุชุฌุงุช", "products", "product"]):
                    return {
                        "answer": f"ุงูููุชุฌุงุช ุงููุชููุฑุฉ ูู ุฏูุงู ูุฌู:\n{self.format_products(data['products'], show_prices=False)}",
                        "source": "database",
                        "confidence": 1.0
                    }
                else:
                    return {
                        "answer": f"ุงูููุชุฌุงุช ุงููุชููุฑุฉ ูู ุฏูุงู ูุฌู:\n{self.format_products(data['products'], show_prices=True)}",
                        "source": "database",
                        "confidence": 1.0
                    }
            
            # Prices queries
            if any(k in q_lower for k in ["ุงูุงุณุนุงุฑ", "prices", "price", "ูู ุงูุณุนุฑ", "ูู ุงูุงุณุนุงุฑ", "ุงูุชูููุฉ", "cost"]):
                data = await self.load_database_data(user_id)
                return {
                    "answer": f"ุฃุณุนุงุฑ ุงูููุชุฌุงุช ูู ุฏูุงู ูุฌู:\n{self.format_products(data['products'], show_prices=True)}",
                    "source": "database",
                    "confidence": 1.0
                }
            
            # Specific product queries (price or info)
            product_keywords = ["ุนุตูุฑ ุงููุฑุงุนู", "ุนุตูุฑ ุงูุฑุจูุน", "ุจุงุฑูู", "ุจุณูุฑูู", "ุฌุงููุณู", "ุณููุชูุฒ", "ููุช ูุงุช", "ููููุฑ", "ุญููุจ ูุงุฏู", "ุฃูุฑูู", "ุจุฑูุชูู ุจุงุฑ", "ุตู ุชูุจ"]
            
            # Check if asking about specific product
            for product in product_keywords:
                if product.lower() in q_lower:
                    # If asking about price specifically
                    if any(k in q_lower for k in ["ูู ุณุนุฑ", "ุณุนุฑ", "ุชูููุฉ", "ุจูู"]):
                        data = await self.load_database_data(user_id)
                        products = data['products']
                        
                        # Find the product
                        product_info = None
                        for p in products:
                            if product.lower() in self.translate_product_name(p.get('name', '')).lower():
                                product_info = p
                                break
                        
                        if product_info:
                            name = self.translate_product_name(product_info.get('name', ''))
                            price = product_info.get('price', 0)
                            return {
                                "answer": f"ุณุนุฑ {name}: {price} ุฑ.ุณ",
                                "source": "database",
                                "confidence": 1.0
                            }
                        else:
                            return {
                                "answer": f"ุนุฐุฑุงูุ ูุง ุฃุฌุฏ {product} ูู ูุงุนุฏุฉ ุงูุจูุงูุงุช.",
                                "source": "database",
                                "confidence": 1.0
                            }
                    else:
                        # Asking for general info about the product
                        web_info = await self.get_product_info_from_web(product)
                        result = f"๐ฆ **ูุนูููุงุช {product}:**\n\n"
                        result += f"๐ **ูุนูููุงุช ูู ุงูุฅูุชุฑูุช:**\n{web_info}"
                        
                        return {
                            "answer": result,
                            "source": "web_only",
                            "confidence": 0.8
                        }
            
            # Branches queries
            if any(k in q_lower for k in ["ุงููุฑูุน", "branches", "branch", "ููู ุงููุฑูุน", "ุฃูู ุงููุฑูุน", "ููุงูุน ุงููุฑูุน", "ูุฑูุนูู"]):
                data = await self.load_database_data(user_id)
                return {
                    "answer": f"ูุฑูุน ุฏูุงู ูุฌู ุงููุชููุฑุฉ:\n{self.format_branches(data['branches'])}",
                    "source": "database",
                    "confidence": 1.0
                }
            
            # Invoices queries - check for user-specific questions
            if any(k in q_lower for k in ["ููุงุชูุฑู", "ููุงุชูุฑู", "invoices", "invoice", "ูู ุนุฏุฏ ููุงุชูุฑู", "ุนุฑุถ ููุงุชูุฑู", "ููุงุชูุฑู"]):
                if user_id:
                    data = await self.load_database_data(user_id)
                    invoice_count = len(data['invoices'])
                    if invoice_count > 0:
                        return {
                            "answer": f"ูุฏูู {invoice_count} ููุงุชูุฑ:\n{self.format_invoices(data['invoices'])}",
                            "source": "database",
                            "confidence": 1.0
                        }
                    else:
                        return {
                            "answer": "ูุง ุชูุฌุฏ ููุงุชูุฑ ูู ุญุชู ุงูุขู.",
                            "source": "database",
                            "confidence": 1.0
                        }
                else:
                    return {
                        "answer": "ุนุฐุฑุงูุ ูุง ูููููู ุนุฑุถ ููุงุชูุฑู ุจุฏูู ุชุณุฌูู ุงูุฏุฎูู. ูุฑุฌู ุชุณุฌูู ุงูุฏุฎูู ุฃููุงู.",
                        "source": "user_auth_required",
                        "confidence": 1.0
                    }
            
            # General invoices query (not user-specific)
            if any(k in q_lower for k in ["ุงูููุงุชูุฑ", "invoices", "invoice"]) and not any(k in q_lower for k in ["ููุงุชูุฑู", "ููุงุชูุฑู"]):
                data = await self.load_database_data(user_id)
                return {
                    "answer": f"ูุนูููุงุช ุนู ุงูููุงุชูุฑ ูู ุฏูุงู ูุฌู:\n{self.format_invoices(data['invoices'])}",
                    "source": "database",
                    "confidence": 1.0
                }
            
            # Use RAG for other questions
            try:
                resp = await self.chain.ainvoke({"question": question})
                return {
                    "answer": resp.get("answer", "ุนุฐุฑุงูุ ูุง ุฃุณุชุทูุน ุงูุฅุฌุงุจุฉ ุนูู ูุฐุง ุงูุณุคุงู."),
                    "source": "rag",
                    "confidence": 0.8,
                    "source_documents": resp.get("source_documents", [])
                }
            except Exception as e:
                logger.error(f"Error in RAG chain: {e}")
                return {
                    "answer": "ุนุฐุฑุงูุ ูุง ุฃุณุชุทูุน ุงูุฅุฌุงุจุฉ ุนูู ูุฐุง ุงูุณุคุงู.",
                    "source": "rag_error",
                    "confidence": 0.0
                }
                
        except Exception as e:
            logger.error(f"Error in ask_question: {e}")
            import traceback
            traceback.print_exc()
            return {"answer": "ุนุฐุฑุงูุ ุญุฏุซ ุฎุทุฃ ูู ูุนุงูุฌุฉ ุณุคุงูู.", "source": "error", "confidence": 0.0}

    async def add_documents(self, documents: List[Dict[str, Any]]) -> bool:
        try:
            docs = []
            for doc in documents:
                content = doc.get('content', '')
                metadata = doc.get('metadata', {}) or {}
                metadata.setdefault('timestamp', datetime.now().isoformat())
                docs.append(Document(page_content=content, metadata=metadata))

            splitter = RecursiveCharacterTextSplitter(
                chunk_size=self.config.chunk_size,
                chunk_overlap=self.config.chunk_overlap
            )
            split_docs = splitter.split_documents(docs)
            self.vector_store.add_documents(split_docs)
            logger.info(f"Added {len(split_docs)} chunks to vector store")
            return True
        except Exception as e:
            logger.error(f"Error adding documents: {e}")
            return False

    async def load_database_data(self, user_id: Optional[str] = None) -> Dict[str, Any]:
        try:
            data: Dict[str, Any] = {}
            data['products'] = self.supabase.table("products").select("*").execute().data or []
            data['branches'] = self.supabase.table("branches").select("*").execute().data or []
            q = self.supabase.table("invoices").select("*")
            if user_id: q = q.eq("user_id", user_id)
            data['invoices'] = q.execute().data or []
            return data
        except Exception as e:
            logger.error(f"Error loading DB: {e}")
            return {"products": [], "branches": [], "invoices": []}

    async def add_knowledge_base(self, knowledge_data: List[Dict[str, Any]]) -> bool:
        """Add knowledge base documents to the system"""
        try:
            docs = []
            for item in knowledge_data:
                docs.append({
                    "content": item.get("content", ""),
                    "metadata": {
                        "type": item.get("type", "general"),
                        "category": item.get("category", "unknown"),
                        "source": item.get("source", "manual"),
                        "timestamp": datetime.now().isoformat(),
                    }
                })
            return await self.add_documents(docs)
        except Exception as e:
            logger.error(f"Error adding knowledge base: {e}")
            return False

    def clear_memory(self, user_id: Optional[str] = None):
        """Clear conversation memory"""
        try:
            if self.memory:
                self.memory.clear()
                logger.info("Conversation memory cleared")
        except Exception as e:
            logger.error(f"Error clearing memory: {e}")

    async def get_conversation_history(self, user_id: Optional[str] = None) -> List[Dict[str, str]]:
        """Get conversation history"""
        try:
            if self.memory and hasattr(self.memory, 'chat_memory'):
                return self.memory.chat_memory.messages
            return []
        except Exception as e:
            logger.error(f"Error getting conversation history: {e}")
            return []
